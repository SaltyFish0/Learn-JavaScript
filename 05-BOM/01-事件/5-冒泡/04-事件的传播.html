<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			#box1 {
				width: 300px;
				height: 300px;
				background: #0ff;
				display: flex;
				justify-content: center;
				align-items: center;
			}

			#box2 {
				width: 200px;
				height: 200px;
				background: #00f;
				display: flex;
				justify-content: center;
				align-items: center;
			}

			#box3 {
				width: 100px;
				height: 100px;
				background: #000;
			}
		</style>
	</head>
	<body>
		<script type="text/javascript">
			window.onload = function() {
				var box1 = document.getElementById("box1");
				var box2 = document.getElementById("box2");
				var box3 = document.getElementById("box3");

				/* 
				 事件的传播
					关于事件的传播网景公司和微软公司有不同的理解
						微软公司认为应该由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播
						网景公司认为应该由外向内传播，也就是当事件触发时，应该先触发当前元素最外层的祖先元素事件，然后再由内传播给后代元素
						最后由W3C决定，W3C综合了两个公司的方案，将事件分为了三个阶段
							1.捕获阶段
								捕获阶段时由最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件
							2.目标阶段
								事件捕获到目标阶段，捕获结束后开始在目标元素上触发事件
							3.冒泡阶段
								事件从目标元素向祖先元素传递，依次触发祖先元素上的事件
								
							如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true
							一般情况下，我们不会希望在捕获阶段触发事件，所以这个参数一般都是false
						IE8及以下浏览器中没有捕获阶段
				 */

				// box1.onclick = function(){
				// 	console.log("box1");
				// }
				// box2.onclick = function(){
				// 	console.log("box2");
				// }
				// box3.onclick = function(){
				// 	console.log("box3");
				// }

				box1.addEventListener("click", function() {
					console.log("box1");
				}, true);

				box2.addEventListener("click", function() {
					console.log("box2");
				}, true);

				box3.addEventListener("click", function() {
					console.log("box3");
				}, true);
			}
		</script>
		<div id="box1">
			<div id="box2">
				<div id="box3"></div>
			</div>
		</div>
	</body>
</html>
